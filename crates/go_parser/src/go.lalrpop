use crate::ast;

grammar;

match {
    "=",
    "(",
    ")",
    ":=",
    "{",
    "}",
    ".",
    "!=",
    ",",

    "if",
    "var",
    "package",
    "import",
    "const",
    "func",
    "type",

    r"`[^`]*`",
    r#""[^"]*""#,
    r"[0-9A-Z_a-z]+",

    r"\s*" => {}, // whitespace
    r"//[^\n\r]*[\n\r]*" => {}, // comments
}

pub Identifier: ast::Identifier = <s:r"[0-9A-Z_a-z]+"> => ast::Identifier::from(s);

pub Type: ast::Type = <t:TypeName> => ast::Type{type_name: t};

pub TypeName: ast::TypeName = <i:Identifier> => ast::TypeName{identifier: i};

pub TopLevelDecl: ast::TopLevelDecl = {
    <d:Declaration> => ast::TopLevelDecl{
        declaration: Some(d),
        function_decl: None,
        method_decl: None,
    },
    <f:FunctionDecl> => ast::TopLevelDecl{
        declaration: None,
        function_decl: Some(f),
        method_decl: None,
    },
    <m:MethodDecl> => ast::TopLevelDecl{
        declaration: None,
        function_decl: None,
        method_decl: Some(m),
    }
};

pub Declaration: ast::Declaration = {
    <c:ConstDecl> => ast::Declaration{
        const_decl: Some(c),
        type_decl: None,
        var_decl: None,
    },
    <t:TypeDecl> => ast::Declaration{
        const_decl: None,
        type_decl: Some(t),
        var_decl: None,
    },
    <v:VarDecl> => ast::Declaration{
        const_decl: None,
        type_decl: None,
        var_decl: Some(v),
    },
};

pub ConstDecl: ast::ConstDecl = "const" <c:ConstSpec> => ast::ConstDecl{const_spec: c};

pub ConstSpec: ast::ConstSpec = <i:List<Identifier>> "=" <e:List<Expression>> => ast::ConstSpec{
    identifier_list: i,
    expression_list: e,
};

pub TypeDecl: ast::TypeDecl = "type" <t:TypeSpec> => ast::TypeDecl{type_spec: t};

pub TypeSpec: ast::TypeSpec = <t:TypeDef> => ast::TypeSpec{type_def: t};

pub TypeDef: ast::TypeDef = <i:Identifier> <t:Type> => ast::TypeDef{
    identifier: i,
    _type: t,
};

pub VarDecl: ast::VarDecl = "var" <v:VarSpec> => ast::VarDecl{var_spec: v};

pub FunctionDecl: ast::FunctionDecl = "func" <n:FunctionName> <s:Signature> <b:FunctionBody> => ast::FunctionDecl{
    function_name: n,
    signature: s,
    function_body: b,
};

pub FunctionName: ast::FunctionName = <i:Identifier> => ast::FunctionName{identifier: i};

pub MethodDecl: ast::MethodDecl = "func" <r:Receiver> <m:MethodName> <s:Signature> <f:FunctionBody> => ast::MethodDecl{
    receiver: r,
    method_name: m,
    signature: s,
    function_body: f,
};

pub Receiver: ast::Receiver = <p:Parameters> => ast::Receiver{parameters: p};

pub Signature: ast::Signature = <p:Parameters> => ast::Signature{parameters: p};

pub Parameters: ast::Parameters = "(" <p:ParameterList> ")" => ast::Parameters{parameter_list: p};

pub ParameterList: ast::ParameterList = <p:ParameterDecl*> => ast::ParameterList{parameter_decls: p};

pub ParameterDecl: ast::ParameterDecl = <t:Type> => ast::ParameterDecl{_type: t};

pub FunctionBody: ast::FunctionBody = <b:Block> => ast::FunctionBody{block: b};

pub ExpressionStmt: ast::ExpressionStmt = <e:Expression> => ast::ExpressionStmt{expression: e};

pub Statement: ast::Statement = {
    <d:Declaration> => ast::Statement{
        declaration: Some(d),
        simple_stmt: None,
        if_stmt: None,
    },
    <s:SimpleStmt> => ast::Statement{
        declaration: None,
        simple_stmt: Some(s),
        if_stmt: None,
    },
    <i:IfStmt> => ast::Statement{
        declaration: None,
        simple_stmt: None,
        if_stmt: Some(i),
    },
};

pub SimpleStmt: ast::SimpleStmt = {
    <e:ExpressionStmt> => ast::SimpleStmt{
        expression_stmt: Some(e),
        short_var_decl: None,
    },
    <s:ShortVarDecl> => ast::SimpleStmt{
        expression_stmt: None,
        short_var_decl: Some(s),
    },
};

pub ShortVarDecl: ast::ShortVarDecl = <i:List<Identifier>> ":=" <e:List<Expression>> => ast::ShortVarDecl{
    identifier_list: i,
    expression_list: e,
};

pub IfStmt: ast::IfStmt = "if" <e:Expression> <b:Block> => ast::IfStmt{
    expression: e,
    block: b,
};

pub StatementList: ast::StatementList = <s:Statement*> => ast::StatementList{statements: s};

pub Block: ast::Block = "{" <s:StatementList> "}" => ast::Block{statement_list: s};

pub Arguments: ast::Arguments = "(" <e:List<Expression>> ","? ")" => ast::Arguments{expression_list: Vec::from(e)};

pub ReceiverType: ast::ReceiverType = <t:Type> => ast::ReceiverType{_type: t};

pub MethodName: ast::MethodName = <i:Identifier> => ast::MethodName::from(i);

pub PrimaryExpr: ast::PrimaryExpr = {
    <o:Operand> => ast::PrimaryExpr{
        operand: Some(o),
        method_expr: None,
        selector: None,
        arguments: None,
    },
    <o:Operand> <a:Arguments> => ast::PrimaryExpr{
        operand: Some(o),
        method_expr: None,
        selector: None,
        arguments: Some(a),
    },
    <m:MethodExpr> <a:Arguments> => ast::PrimaryExpr{
        operand: None,
        method_expr: Some(m),
        selector: None,
        arguments: Some(a),
    },
    <m:MethodExpr> <a:Arguments> <s:Selector> <a2:Arguments> => ast::PrimaryExpr{
        operand: None,
        method_expr: Some(m),
        selector: Some(s),
        arguments: Some(a),
    },
};

pub Operand: ast::Operand = {
    <l:@L> <literal:Literal> => ast::Operand{
        loc: l,
        literal: Some(literal),
        operand_name: None,
    },
    <l:@L> <o:OperandName> => ast::Operand{
        loc: l,
        literal: None,
        operand_name: Some(o),
    },
};

pub Literal: ast::Literal = <b:BasicLit> => ast::Literal{basic_lit: b};

pub BasicLit: ast::BasicLit = <s:StringLit> => ast::BasicLit{string_lit: s};

pub StringLit: ast::StringLit = {
    <r:RawStringLit> => ast::StringLit{
        raw_string_lit: Some(r),
        interpreted_string_lit: None,
    },
    <i:InterpretedStringLit> => ast::StringLit{
        raw_string_lit: None,
        interpreted_string_lit: Some(i),
    },
};

pub RawStringLit: ast::RawStringLit = <s:r"`[^`]*`"> => ast::RawStringLit::from(s.trim_matches('`'));

pub InterpretedStringLit: ast::InterpretedStringLit = <s:r#""[^"]*""#> => ast::InterpretedStringLit::from(s.trim_matches('"'));

pub OperandName: ast::OperandName = <i:Identifier> => ast::OperandName{identifier: i};

pub MethodExpr: ast::MethodExpr = <r:ReceiverType> "." <m:MethodName> => ast::MethodExpr{
    receiver_type: r,
    method_name: m,
};

pub Selector: ast::Selector = "." <i:Identifier> => ast::Selector{identifier: i};

pub UnaryExpr: ast::UnaryExpr = <p:PrimaryExpr> => ast::UnaryExpr{primary_expr: p};

List<T>: Vec<T> = {
    <e:T> => vec![e],
    <mut v: List<T>> "," <e:T> => {
        v.push(e);
        v
    }
};

pub VarSpec: ast::VarSpec = <i:List<Identifier>> "=" <e:List<Expression>> => ast::VarSpec{
    identifier_list: i,
    expression_list: e,
};

pub Expression: ast::Expression = {
    #[precedence(level="0")]
    <u:UnaryExpr> => ast::Expression{
        unary_expr: Some(u),
        expression1: None,
        expression2: None,
    },
    #[precedence(level="1")] #[assoc(side="left")]
    <e1:Expression> "!=" <e2:Expression> => ast::Expression{
        unary_expr: None,
        expression1: Some(Box::new(e1)),
        expression2: Some(Box::new(e2)),
    },
};

pub SourceFile: ast::SourceFile = <p:PackageClause> <i:ImportDecl> <t:TopLevelDecl*> => ast::SourceFile{
    package_clause: p,
    import_decl: i,
    top_level_decls: t,
};

pub PackageClause: ast::PackageClause = "package" <p:PackageName> => ast::PackageClause{package_name: p};

pub PackageName: ast::PackageName = <i:Identifier> => ast::PackageName::from(i);

pub ImportDecl: ast::ImportDecl = {
    "import" <s:ImportSpec> => ast::ImportDecl{import_spec: vec![s]},
    "import" "(" <s:ImportSpec*> ")" => ast::ImportDecl{import_spec: s},
};

pub ImportSpec: ast::ImportSpec = <i:ImportPath> => ast::ImportSpec{import_path: i};

pub ImportPath: ast::ImportPath = <s:StringLit> => ast::ImportPath{string_lit: s};